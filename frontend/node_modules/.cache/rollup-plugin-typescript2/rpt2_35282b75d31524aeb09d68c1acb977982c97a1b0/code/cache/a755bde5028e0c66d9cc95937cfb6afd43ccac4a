{"code":"import { __decorate } from \"tslib\";\r\nimport { LitElement, html, css, nothing, render, } from 'lit';\r\nimport { property, customElement, state, query } from 'lit/decorators.js';\r\nimport { fireEvent } from 'custom-card-helpers';\r\nimport { mdiClose, mdiMenuUp, mdiMenuDown } from '@mdi/js';\r\nimport { IsEqual, isDefined } from '../helpers';\r\nimport { directive, Directive, PartType } from 'lit/directive';\r\nlet AlarmoSelect = class AlarmoSelect extends LitElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.label = '';\r\n        this.items = [];\r\n        this.clearable = false;\r\n        this.icons = false;\r\n        this.disabled = false;\r\n        this.invalid = false;\r\n        this.rowRenderer = item => {\r\n            const hasDescription = isDefined(item.description);\r\n            if (this.icons) {\r\n                return html `\n        <style>\n          mwc-list-item {\n            font-size: 15px;\n            --mdc-typography-body2-font-size: 14px;\n            --mdc-list-item-meta-size: 8px;\n            --mdc-list-item-graphic-margin: 8px;\n          }\n        </style>\n        <mwc-list-item graphic=\"avatar\" .twoline=${hasDescription}>\n          <ha-icon icon=\"${item.icon}\" slot=\"graphic\"></ha-icon>\n          <span>${item.name}</span>\n          ${hasDescription\r\n                    ? html `\n                <span slot=\"secondary\">${item.description}</span>\n              `\r\n                    : ''}\n        </mwc-list-item>\n      `;\r\n            }\r\n            else {\r\n                return html `\n        <style>\n          mwc-list-item {\n            font-size: 15px;\n            --mdc-typography-body2-font-size: 14px;\n          }\n        </style>\n        <mwc-list-item .twoline=${hasDescription}>\n          <span>${item.name}</span>\n          ${hasDescription\r\n                    ? html `\n                <span slot=\"secondary\">${item.description}</span>\n              `\r\n                    : ''}\n        </mwc-list-item>\n      `;\r\n            }\r\n        };\r\n    }\r\n    open() {\r\n        this.updateComplete.then(() => {\r\n            var _a, _b;\r\n            (_b = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('vaadin-combo-box-light')) === null || _b === void 0 ? void 0 : _b.open();\r\n        });\r\n    }\r\n    disconnectedCallback() {\r\n        super.disconnectedCallback();\r\n        if (this._overlayMutationObserver) {\r\n            this._overlayMutationObserver.disconnect();\r\n            this._overlayMutationObserver = undefined;\r\n        }\r\n    }\r\n    focus() {\r\n        this.updateComplete.then(() => {\r\n            var _a;\r\n            ((_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('ha-textfield')).focus();\r\n        });\r\n    }\r\n    shouldUpdate(changedProps) {\r\n        if (changedProps.get('items')) {\r\n            if (!IsEqual(this.items, changedProps.get('items')))\r\n                this.firstUpdated();\r\n            else if (changedProps.size == 1)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    firstUpdated() {\r\n        this._comboBox.items = this.items;\r\n    }\r\n    render() {\r\n        const hasValue = isDefined(this._value) && this.items.find(e => e.value == this._value);\r\n        return html `\n      <vaadin-combo-box-light\n        item-value-path=\"value\"\n        item-id-path=\"value\"\n        item-label-path=\"name\"\n        .value=${this._value}\n        ${comboBoxRenderer(this.rowRenderer)}\n        .allowCustomValue=${this.allowCustomValue}\n        ?disabled=${this.disabled}\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._valueChanged}\n      >\n        <ha-textfield\n          .label=${this.label}\n          class=\"input\"\n          autocapitalize=\"none\"\n          autocomplete=\"off\"\n          autocorrect=\"off\"\n          spellcheck=\"false\"\n          ?disabled=${this.disabled}\n          ?invalid=${this.invalid}\n          .icon=${this.icons && hasValue}\n        >\n          <ha-icon\n            name=\"icon\"\n            slot=\"leadingIcon\"\n            icon=\"${this.icons && hasValue ? this.items.find(e => e.value == this._value).icon : undefined}\"\n          ></ha-icon>\n        </ha-textfield>\n        <ha-svg-icon\n          class=\"toggle-button ${this.items.length ? '' : 'disabled'}\"\n          .path=${this._opened && this.items.length ? mdiMenuUp : mdiMenuDown}\n          @click=${this._toggleOpen}\n        ></ha-svg-icon>\n        ${this.clearable && hasValue\r\n            ? html `\n              <ha-svg-icon class=\"clear-button\" @click=${this._clearValue} .path=${mdiClose}></ha-svg-icon>\n            `\r\n            : ''}\n      </vaadin-combo-box-light>\n    `;\r\n    }\r\n    _clearValue(ev) {\r\n        ev.stopPropagation();\r\n        this._setValue('');\r\n    }\r\n    get _value() {\r\n        return isDefined(this.value) ? this.value : '';\r\n    }\r\n    _toggleOpen(ev) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        if (!this.items.length) {\r\n            ev.stopPropagation();\r\n            return;\r\n        }\r\n        if (this._opened) {\r\n            (_c = (_b = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('vaadin-combo-box-light')) === null || _b === void 0 ? void 0 : _b.inputElement) === null || _c === void 0 ? void 0 : _c.blur();\r\n            ev.stopPropagation();\r\n        }\r\n        else {\r\n            (_f = (_e = (_d = this.shadowRoot) === null || _d === void 0 ? void 0 : _d.querySelector('vaadin-combo-box-light')) === null || _e === void 0 ? void 0 : _e.inputElement) === null || _f === void 0 ? void 0 : _f.focus();\r\n        }\r\n    }\r\n    _openedChanged(ev) {\r\n        this._opened = ev.detail.value;\r\n        if (this._opened && 'MutationObserver' in window && !this._overlayMutationObserver) {\r\n            const overlay = document.querySelector('vaadin-combo-box-overlay');\r\n            if (!overlay)\r\n                return;\r\n            this._overlayMutationObserver = new MutationObserver(mutations => {\r\n                mutations.forEach(mutation => {\r\n                    var _a;\r\n                    if (mutation.type === 'attributes' &&\r\n                        mutation.attributeName === 'inert' &&\r\n                        // @ts-expect-error\r\n                        overlay.inert === true) {\r\n                        // @ts-expect-error\r\n                        overlay.inert = false;\r\n                        (_a = this._overlayMutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n                        this._overlayMutationObserver = undefined;\r\n                    }\r\n                    else if (mutation.type === 'childList') {\r\n                        mutation.removedNodes.forEach(node => {\r\n                            var _a;\r\n                            if (node.nodeName === 'VAADIN-COMBO-BOX-OVERLAY') {\r\n                                (_a = this._overlayMutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n                                this._overlayMutationObserver = undefined;\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n            this._overlayMutationObserver.observe(overlay, {\r\n                attributes: true,\r\n            });\r\n            this._overlayMutationObserver.observe(document.body, {\r\n                childList: true,\r\n            });\r\n        }\r\n    }\r\n    _valueChanged(ev) {\r\n        const newValue = ev.detail.value;\r\n        if (newValue !== this._value) {\r\n            this._setValue(newValue);\r\n        }\r\n    }\r\n    _setValue(value) {\r\n        this.value = value;\r\n        setTimeout(() => {\r\n            fireEvent(this, 'value-changed', { value });\r\n        }, 0);\r\n    }\r\n    static get styles() {\r\n        return css `\n      :host {\n        display: block;\n      }\n      vaadin-combo-box-light {\n        position: relative;\n      }\n      ha-textfield {\n        width: 100%;\n      }\n      ha-textfield > ha-icon-button {\n        --mdc-icon-button-size: 24px;\n        padding: 2px;\n        color: var(--secondary-text-color);\n      }\n      ha-svg-icon {\n        color: var(--input-dropdown-icon-color);\n        position: absolute;\n        cursor: pointer;\n      }\n      ha-svg-icon.disabled {\n        cursor: default;\n        color: var(--disabled-text-color);\n      }\n      .toggle-button {\n        right: 12px;\n        bottom: 5px;\n      }\n      :host([opened]) .toggle-button {\n        color: var(--primary-color);\n      }\n      .clear-button {\n        --mdc-icon-size: 20px;\n        bottom: 5px;\n        right: 36px;\n      }\n    `;\r\n    }\r\n};\r\n__decorate([\r\n    property()\r\n], AlarmoSelect.prototype, \"label\", void 0);\r\n__decorate([\r\n    property()\r\n], AlarmoSelect.prototype, \"value\", void 0);\r\n__decorate([\r\n    property()\r\n], AlarmoSelect.prototype, \"items\", void 0);\r\n__decorate([\r\n    property()\r\n], AlarmoSelect.prototype, \"clearable\", void 0);\r\n__decorate([\r\n    property()\r\n], AlarmoSelect.prototype, \"icons\", void 0);\r\n__decorate([\r\n    property({ type: Boolean })\r\n], AlarmoSelect.prototype, \"disabled\", void 0);\r\n__decorate([\r\n    state()\r\n], AlarmoSelect.prototype, \"_opened\", void 0);\r\n__decorate([\r\n    property({ attribute: 'allow-custom-value', type: Boolean })\r\n], AlarmoSelect.prototype, \"allowCustomValue\", void 0);\r\n__decorate([\r\n    property({ type: Boolean })\r\n], AlarmoSelect.prototype, \"invalid\", void 0);\r\n__decorate([\r\n    query('vaadin-combo-box-light', true)\r\n], AlarmoSelect.prototype, \"_comboBox\", void 0);\r\nAlarmoSelect = __decorate([\r\n    customElement('alarmo-select')\r\n], AlarmoSelect);\r\nexport { AlarmoSelect };\r\n// A sentinel that indicates renderer hasn't been initialized\r\nconst initialValue = {};\r\nexport class AbstractRendererDirective extends Directive {\r\n    constructor(part) {\r\n        super(part);\r\n        this.previousValue = initialValue;\r\n        if (part.type !== PartType.ELEMENT) {\r\n            throw new Error('renderer only supports binding to element');\r\n        }\r\n    }\r\n    render(_renderer, _value) {\r\n        return nothing;\r\n    }\r\n    update(part, [renderer, value]) {\r\n        var _a;\r\n        const firstRender = this.previousValue === initialValue;\r\n        if (!this.hasChanged(value)) {\r\n            return nothing;\r\n        }\r\n        // Copy the value if it's an array so that if it's mutated we don't forget\r\n        // what the previous values were.\r\n        this.previousValue = Array.isArray(value) ? Array.from(value) : value;\r\n        const element = part.element;\r\n        // TODO: support re-assigning renderer function.\r\n        if (firstRender) {\r\n            const host = (_a = part.options) === null || _a === void 0 ? void 0 : _a.host;\r\n            this.addRenderer(element, renderer, { host });\r\n        }\r\n        else {\r\n            this.runRenderer(element);\r\n        }\r\n        return nothing;\r\n    }\r\n    hasChanged(value) {\r\n        let result = true;\r\n        if (Array.isArray(value)) {\r\n            // Dirty-check arrays by item\r\n            if (Array.isArray(this.previousValue) &&\r\n                this.previousValue.length === value.length &&\r\n                value.every((v, i) => v === this.previousValue[i])) {\r\n                result = false;\r\n            }\r\n        }\r\n        else if (this.previousValue === value) {\r\n            // Dirty-check non-arrays by identity\r\n            result = false;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass ComboBoxRendererDirective extends AbstractRendererDirective {\r\n    /**\r\n     * Set renderer callback to the element.\r\n     */\r\n    addRenderer(element, renderer, options) {\r\n        element.renderer = (root, comboBox, model) => {\r\n            render(renderer.call(options.host, model.item, model, comboBox), root, options);\r\n        };\r\n    }\r\n    /**\r\n     * Run renderer callback on the element.\r\n     */\r\n    runRenderer(element) {\r\n        element.requestContentUpdate();\r\n    }\r\n}\r\nconst rendererDirective = directive(ComboBoxRendererDirective);\r\nexport const comboBoxRenderer = (renderer, value) => rendererDirective(renderer, value);\r\n","references":["/workspaces/RacelandHA/config/custom_components/alarmo/frontend/node_modules/lit/index.d.ts","/workspaces/RacelandHA/config/custom_components/alarmo/frontend/node_modules/lit/decorators.d.ts","/workspaces/RacelandHA/config/custom_components/alarmo/frontend/node_modules/custom-card-helpers/dist/index.d.ts","/workspaces/RacelandHA/config/custom_components/alarmo/frontend/node_modules/@mdi/js/mdi.d.ts","/workspaces/RacelandHA/config/custom_components/alarmo/frontend/src/helpers.ts","/workspaces/RacelandHA/config/custom_components/alarmo/frontend/node_modules/lit/directive.d.ts"]}
