{"code":"import { localize } from '../../localize/localize';\r\nimport { EArmModes, EAlarmEvent } from '../types';\r\nimport { EArmModeIcons } from '../const';\r\nimport { computeDomain, computeEntity, domainIcon } from 'custom-card-helpers';\r\nimport { Unique, isDefined, sortAlphabetically } from '../helpers';\r\nexport const computeArmModeDisplay = (val, hass) => {\r\n    switch (val) {\r\n        case EArmModes.ArmedAway:\r\n            return {\r\n                value: EArmModes.ArmedAway,\r\n                name: localize('common.modes_short.armed_away', hass.language),\r\n                icon: EArmModeIcons.ArmedAway,\r\n            };\r\n        case EArmModes.ArmedHome:\r\n            return {\r\n                value: EArmModes.ArmedHome,\r\n                name: localize('common.modes_short.armed_home', hass.language),\r\n                icon: EArmModeIcons.ArmedHome,\r\n            };\r\n        case EArmModes.ArmedNight:\r\n            return {\r\n                value: EArmModes.ArmedNight,\r\n                name: localize('common.modes_short.armed_night', hass.language),\r\n                icon: EArmModeIcons.ArmedNight,\r\n            };\r\n        case EArmModes.ArmedCustom:\r\n            return {\r\n                value: EArmModes.ArmedCustom,\r\n                name: localize('common.modes_short.armed_custom_bypass', hass.language),\r\n                icon: EArmModeIcons.ArmedCustom,\r\n            };\r\n        case EArmModes.ArmedVacation:\r\n            return {\r\n                value: EArmModes.ArmedVacation,\r\n                name: localize('common.modes_short.armed_vacation', hass.language),\r\n                icon: EArmModeIcons.ArmedVacation,\r\n            };\r\n    }\r\n};\r\nexport const computeEventDisplay = (event, hass) => {\r\n    switch (event) {\r\n        case EAlarmEvent.Armed:\r\n            return {\r\n                value: EAlarmEvent.Armed,\r\n                name: localize('panels.actions.cards.new_notification.fields.event.choose.armed.name', hass.language),\r\n                description: localize('panels.actions.cards.new_notification.fields.event.choose.armed.description', hass.language),\r\n                icon: 'hass:shield-check-outline',\r\n            };\r\n        case EAlarmEvent.Disarmed:\r\n            return {\r\n                value: EAlarmEvent.Disarmed,\r\n                name: localize('panels.actions.cards.new_notification.fields.event.choose.disarmed.name', hass.language),\r\n                description: localize('panels.actions.cards.new_notification.fields.event.choose.disarmed.description', hass.language),\r\n                icon: 'hass:shield-off-outline',\r\n            };\r\n        case EAlarmEvent.Triggered:\r\n            return {\r\n                value: EAlarmEvent.Triggered,\r\n                name: localize('panels.actions.cards.new_notification.fields.event.choose.triggered.name', hass.language),\r\n                description: localize('panels.actions.cards.new_notification.fields.event.choose.triggered.description', hass.language),\r\n                icon: 'hass:bell-alert-outline',\r\n            };\r\n        case EAlarmEvent.Untriggered:\r\n            return {\r\n                value: EAlarmEvent.Untriggered,\r\n                name: localize('panels.actions.cards.new_notification.fields.event.choose.untriggered.name', hass.language),\r\n                description: localize('panels.actions.cards.new_notification.fields.event.choose.untriggered.description', hass.language),\r\n                icon: 'hass:bell-off-outline',\r\n            };\r\n        case EAlarmEvent.ArmFailure:\r\n            return {\r\n                value: EAlarmEvent.ArmFailure,\r\n                name: localize('panels.actions.cards.new_notification.fields.event.choose.arm_failure.name', hass.language),\r\n                description: localize('panels.actions.cards.new_notification.fields.event.choose.arm_failure.description', hass.language),\r\n                icon: 'hass:alert-outline',\r\n            };\r\n        case EAlarmEvent.Arming:\r\n            return {\r\n                value: EAlarmEvent.Arming,\r\n                name: localize('panels.actions.cards.new_notification.fields.event.choose.arming.name', hass.language),\r\n                description: localize('panels.actions.cards.new_notification.fields.event.choose.arming.description', hass.language),\r\n                icon: 'hass:home-export-outline',\r\n            };\r\n        case EAlarmEvent.Pending:\r\n            return {\r\n                value: EAlarmEvent.Pending,\r\n                name: localize('panels.actions.cards.new_notification.fields.event.choose.pending.name', hass.language),\r\n                description: localize('panels.actions.cards.new_notification.fields.event.choose.pending.description', hass.language),\r\n                icon: 'hass:home-import-outline',\r\n            };\r\n    }\r\n};\r\nexport const computeAreaDisplay = (area, areaConfig, alarmoConfig) => {\r\n    if (area == 0) {\r\n        return {\r\n            name: alarmoConfig.master.name,\r\n            value: 0,\r\n        };\r\n    }\r\n    else if (Object.keys(areaConfig).includes(String(area))) {\r\n        return {\r\n            name: areaConfig[area].name,\r\n            value: area,\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            name: String(area),\r\n            value: area,\r\n        };\r\n    }\r\n};\r\nexport const computeServiceDisplay = (hass, ...services) => {\r\n    const output = services\r\n        .map(service => {\r\n        if (!service)\r\n            return null;\r\n        const domain = computeDomain(service);\r\n        const domainService = computeEntity(service);\r\n        let data = {\r\n            value: service,\r\n            name: domainService\r\n                .replace(/_/g, ' ')\r\n                .split(' ')\r\n                .map(e => e.substring(0, 1).toUpperCase() + e.substring(1))\r\n                .join(' '),\r\n            icon: 'hass:home',\r\n            description: service,\r\n        };\r\n        switch (domain) {\r\n            case 'notify':\r\n                const stateObj = hass.states[`device_tracker.${domainService.replace('mobile_app_', '')}`];\r\n                data = stateObj\r\n                    ? Object.assign(Object.assign({}, data), { name: stateObj.attributes.friendly_name || computeEntity(stateObj.entity_id), icon: stateObj.attributes.icon || 'hass:cellphone-text' }) : Object.assign(Object.assign({}, data), { icon: 'hass:comment-alert' });\r\n                break;\r\n            case 'tts':\r\n                data = Object.assign(Object.assign({}, data), { icon: 'hass:microphone' });\r\n                break;\r\n        }\r\n        return data;\r\n    })\r\n        .filter(isDefined);\r\n    output.sort((a, b) => {\r\n        const domainA = computeDomain(a.value);\r\n        const domainB = computeDomain(b.value);\r\n        if (domainA != domainB)\r\n            return sortAlphabetically(domainA, domainB);\r\n        return sortAlphabetically(a, b);\r\n    });\r\n    return output;\r\n};\r\nexport const getAreaOptions = (areaConfig, alarmoConfig) => {\r\n    let areas = [];\r\n    const area_ids = Object.keys(areaConfig).filter(e => Object.values(areaConfig[e].modes).some(v => v.enabled));\r\n    if (alarmoConfig.master.enabled && area_ids.length > 1)\r\n        areas = [...areas, 0];\r\n    areas = [...areas, ...area_ids];\r\n    return areas;\r\n};\r\nexport const getArmModeOptions = (area, areaConfig) => {\r\n    const areaList = (areaCfg) => Object.keys(areaCfg.modes).filter(mode => areaCfg.modes[mode].enabled);\r\n    if (!isDefined(area) || !Object.keys(areaConfig).includes(String(area))) {\r\n        const modeLists = Object.keys(areaConfig).map(e => areaList(areaConfig[e]));\r\n        return modeLists[0].filter(e => modeLists.every(m => m.includes(e)));\r\n    }\r\n    else {\r\n        return areaList(areaConfig[area]);\r\n    }\r\n};\r\nexport const computeEntityDisplay = (entity_id, hass) => {\r\n    const data = entity_id.map(e => {\r\n        const output = {\r\n            value: e,\r\n            name: e in hass.states ? hass.states[e].attributes.friendly_name || computeEntity(e) : e,\r\n            icon: e in hass.states ? hass.states[e].attributes.icon || domainIcon(computeDomain(e)) : undefined,\r\n            description: e,\r\n        };\r\n        return output;\r\n    });\r\n    return data;\r\n};\r\nexport const getNotifyServices = (hass) => {\r\n    let res = [];\r\n    if ('notify' in hass.services)\r\n        res = [...res, ...Object.keys(hass.services.notify).map(service => `notify.${service}`)];\r\n    if ('tts' in hass.services)\r\n        res = [\r\n            ...res,\r\n            ...Object.keys(hass.services.tts)\r\n                .filter(e => e != 'clear_cache')\r\n                .map(service => `tts.${service}`),\r\n        ];\r\n    return res;\r\n};\r\nexport const computeMergedActions = (...actionLists) => {\r\n    if (!actionLists.length || !actionLists.every(e => e.length))\r\n        return [];\r\n    if (actionLists.length == 1 && actionLists[0].length > 1 && Unique(actionLists[0].map(computeDomain)).length > 1)\r\n        return computeMergedActions(...actionLists[0].map(e => Array(e)));\r\n    let intersection = [...actionLists[0]];\r\n    actionLists.forEach(list => {\r\n        intersection = intersection\r\n            .map(e => {\r\n            if (list.includes(e))\r\n                return e;\r\n            else if (computeDomain(e) == 'script' && list.map(computeDomain).includes('script'))\r\n                return `script.script`;\r\n            else if (list.map(computeEntity).includes(computeEntity(e)))\r\n                return `homeassistant.${computeEntity(e)}`;\r\n            else\r\n                return null;\r\n        })\r\n            .filter(isDefined);\r\n    });\r\n    return intersection;\r\n};\r\nexport const computeActions = (entity_id, hass, recursionDepth = 1) => {\r\n    if (recursionDepth > 10)\r\n        return [];\r\n    if (Array.isArray(entity_id)) {\r\n        const actionLists = entity_id.map(e => computeActions(e, hass, recursionDepth + 1));\r\n        return computeMergedActions(...actionLists);\r\n    }\r\n    else if (!isDefined(entity_id))\r\n        return [];\r\n    const domain = computeDomain(entity_id);\r\n    switch (domain) {\r\n        case 'light':\r\n        case 'switch':\r\n        case 'input_boolean':\r\n        case 'siren':\r\n            return [`${domain}.turn_on`, `${domain}.turn_off`];\r\n        case 'script':\r\n            return [entity_id];\r\n        case 'lock':\r\n            return ['lock.lock', 'lock.unlock'];\r\n        case 'group':\r\n            const groupObj = entity_id in hass.states ? hass.states[entity_id] : undefined;\r\n            const entities = (groupObj === null || groupObj === void 0 ? void 0 : groupObj.attributes.entity_id) || [];\r\n            return computeActions(entities, hass, recursionDepth + 1);\r\n        default:\r\n            return [];\r\n    }\r\n};\r\nexport const getAutomationEntities = (hass, additionalEntities) => {\r\n    let entities = [...Object.keys(hass.states).filter(e => computeActions(e, hass).length)];\r\n    if (additionalEntities && additionalEntities.length) {\r\n        entities = [...entities, ...additionalEntities.filter(e => !entities.includes(e))];\r\n    }\r\n    entities.sort(sortAlphabetically);\r\n    return entities;\r\n};\r\nexport const getMediaPlayerEntities = (hass) => {\r\n    const entities = [...Object.keys(hass.states).filter(e => computeDomain(e) == 'media_player')];\r\n    entities.sort(sortAlphabetically);\r\n    return entities;\r\n};\r\nexport const getWildcardOptions = (event, alarmoConfig) => {\r\n    let options = [];\r\n    options = [];\r\n    if (!event || [EAlarmEvent.Pending, EAlarmEvent.Triggered, EAlarmEvent.ArmFailure].includes(event))\r\n        options = [\r\n            ...options,\r\n            {\r\n                name: 'Open Sensors',\r\n                value: '{{open_sensors}}',\r\n            },\r\n        ];\r\n    if (!event || [EAlarmEvent.Armed].includes(event))\r\n        options = [\r\n            ...options,\r\n            {\r\n                name: 'Bypassed Sensors',\r\n                value: '{{bypassed_sensors}}',\r\n            },\r\n        ];\r\n    if (!event ||\r\n        ((alarmoConfig === null || alarmoConfig === void 0 ? void 0 : alarmoConfig.code_arm_required) &&\r\n            [EAlarmEvent.Armed, EAlarmEvent.Arming, EAlarmEvent.ArmFailure].includes(event)) ||\r\n        ((alarmoConfig === null || alarmoConfig === void 0 ? void 0 : alarmoConfig.code_disarm_required) && [EAlarmEvent.Disarmed, EAlarmEvent.Untriggered].includes(event)))\r\n        options = [\r\n            ...options,\r\n            {\r\n                name: 'Changed By',\r\n                value: '{{changed_by}}',\r\n            },\r\n        ];\r\n    if (!event ||\r\n        [\r\n            EAlarmEvent.Armed,\r\n            EAlarmEvent.Arming,\r\n            EAlarmEvent.Pending,\r\n            EAlarmEvent.Triggered,\r\n            EAlarmEvent.ArmFailure,\r\n        ].includes(event))\r\n        options = [\r\n            ...options,\r\n            {\r\n                name: 'Arm Mode',\r\n                value: '{{arm_mode}}',\r\n            },\r\n        ];\r\n    return options;\r\n};\r\nexport const getOpenSensorsWildCardOptions = (hass) => {\r\n    let options = [];\r\n    if (hass.language != 'en')\r\n        options = [\r\n            ...options,\r\n            {\r\n                value: '{{open_sensors}}',\r\n                name: `${localize('panels.actions.cards.new_notification.fields.open_sensors_format.options.default', hass.language)} (${hass.translationMetadata.translations['en'].nativeName})`,\r\n            },\r\n            {\r\n                value: `{{open_sensors|lang=${hass.language}}}`,\r\n                name: `${localize('panels.actions.cards.new_notification.fields.open_sensors_format.options.default', hass.language)} (${hass.translationMetadata.translations[hass.language].nativeName})`,\r\n            },\r\n        ];\r\n    else\r\n        options = [\r\n            ...options,\r\n            {\r\n                value: '{{open_sensors}}',\r\n                name: localize('panels.actions.cards.new_notification.fields.open_sensors_format.options.default', hass.language),\r\n            },\r\n        ];\r\n    options = [\r\n        ...options,\r\n        {\r\n            value: '{{open_sensors|format=short}}',\r\n            name: localize('panels.actions.cards.new_notification.fields.open_sensors_format.options.short', hass.language),\r\n        },\r\n    ];\r\n    return options;\r\n};\r\nexport const getArmModeWildCardOptions = (hass) => {\r\n    let options = [\r\n        {\r\n            value: '{{arm_mode}}',\r\n            name: hass.translationMetadata.translations['en'].nativeName,\r\n        },\r\n    ];\r\n    if (hass.language != 'en')\r\n        options = [\r\n            ...options,\r\n            {\r\n                value: `{{arm_mode|lang=${hass.language}}}`,\r\n                name: hass.translationMetadata.translations[hass.language].nativeName,\r\n            },\r\n        ];\r\n    return options;\r\n};\r\nexport const isValidString = (input) => {\r\n    return typeof input == 'string' && input.trim().length;\r\n};\r\nexport const isValidService = (input, hass) => {\r\n    return (isValidString(input) &&\r\n        hass.services[computeDomain(input)] &&\r\n        hass.services[computeDomain(input)][computeEntity(input)]);\r\n};\r\nexport const isValidEntity = (input, hass) => {\r\n    return isValidString(input) && hass.states[input];\r\n};\r\nexport const isObject = (input) => typeof input === 'object' && input !== null && !Array.isArray(input);\r\nexport const isArray = (input) => typeof input === 'object' && input !== null && Array.isArray(input);\r\nexport const isString = (input) => typeof input === 'string';\r\nexport const computeActionDisplay = (action, hass) => {\r\n    let service = computeEntity(action);\r\n    if (computeDomain(action) == 'script')\r\n        service = 'run';\r\n    switch (service) {\r\n        case 'turn_on':\r\n            return hass.localize('ui.card.media_player.turn_on');\r\n        case 'turn_off':\r\n            return hass.localize('ui.card.media_player.turn_off');\r\n        case 'lock':\r\n            return hass.localize('ui.card.lock.lock');\r\n        case 'unlock':\r\n            return hass.localize('ui.card.lock.unlock');\r\n        case 'run':\r\n            return hass.localize('ui.card.script.run');\r\n        default:\r\n            return service;\r\n    }\r\n};\r\nexport const findMatchingAction = (actionList, matchedAction) => {\r\n    return actionList.find(action => {\r\n        return (action == matchedAction ||\r\n            (computeEntity(matchedAction) == 'turn_on' && computeEntity(action) == 'turn_on') ||\r\n            (computeEntity(matchedAction) == 'turn_off' && computeEntity(action) == 'turn_off') ||\r\n            (computeDomain(matchedAction) == 'script' && computeDomain(action) == 'script'));\r\n    });\r\n};\r\n","references":["/workspaces/RacelandHA/config/custom_components/alarmo/frontend/localize/localize.ts","/workspaces/RacelandHA/config/custom_components/alarmo/frontend/src/types.ts","/workspaces/RacelandHA/config/custom_components/alarmo/frontend/src/const.ts","/workspaces/RacelandHA/config/custom_components/alarmo/frontend/node_modules/custom-card-helpers/dist/index.d.ts","/workspaces/RacelandHA/config/custom_components/alarmo/frontend/src/helpers.ts"]}
